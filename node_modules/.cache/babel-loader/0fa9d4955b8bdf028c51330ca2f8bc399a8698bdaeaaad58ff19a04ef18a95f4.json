{"ast":null,"code":"import { Texture } from '../core/Texture.js';\n\n// TODO: Support cubemaps\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nexport class KTXTexture extends Texture {\n  constructor(gl) {\n    let {\n      buffer,\n      wrapS = gl.CLAMP_TO_EDGE,\n      wrapT = gl.CLAMP_TO_EDGE,\n      anisotropy = 0,\n      minFilter,\n      magFilter\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, {\n      generateMipmaps: false,\n      wrapS,\n      wrapT,\n      anisotropy,\n      minFilter,\n      magFilter\n    });\n    if (buffer) return this.parseBuffer(buffer);\n  }\n  parseBuffer(buffer) {\n    const ktx = new KhronosTextureContainer(buffer);\n    ktx.mipmaps.isCompressedTexture = true;\n\n    // Update texture\n    this.image = ktx.mipmaps;\n    this.internalFormat = ktx.glInternalFormat;\n    if (ktx.numberOfMipmapLevels > 1) {\n      if (this.minFilter === this.gl.LINEAR) this.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    } else {\n      if (this.minFilter === this.gl.NEAREST_MIPMAP_LINEAR) this.minFilter = this.gl.LINEAR;\n    }\n\n    // TODO: support cube maps\n    // ktx.numberOfFaces\n  }\n}\nfunction KhronosTextureContainer(buffer) {\n  const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n  const id = new Uint8Array(buffer, 0, 12);\n  for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) return console.error('File missing KTX identifier');\n\n  // TODO: Is this always 4? Tested: [android, macos]\n  const size = Uint32Array.BYTES_PER_ELEMENT;\n  const head = new DataView(buffer, 12, 13 * size);\n  const littleEndian = head.getUint32(0, true) === 0x04030201;\n  const glType = head.getUint32(1 * size, littleEndian);\n  if (glType !== 0) return console.warn('only compressed formats currently supported');\n  this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n  let width = head.getUint32(6 * size, littleEndian);\n  let height = head.getUint32(7 * size, littleEndian);\n  this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n  this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n  const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n  this.mipmaps = [];\n  let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n  for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n    const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n    offset += 4; // levelSize field\n    for (let face = 0; face < this.numberOfFaces; face++) {\n      const data = new Uint8Array(buffer, offset, levelSize);\n      this.mipmaps.push({\n        data,\n        width,\n        height\n      });\n      offset += levelSize;\n      offset += 3 - (levelSize + 3) % 4; // add padding for odd sized image\n    }\n    width = width >> 1;\n    height = height >> 1;\n  }\n}","map":{"version":3,"names":["Texture","KTXTexture","constructor","gl","buffer","wrapS","CLAMP_TO_EDGE","wrapT","anisotropy","minFilter","magFilter","arguments","length","undefined","generateMipmaps","parseBuffer","ktx","KhronosTextureContainer","mipmaps","isCompressedTexture","image","internalFormat","glInternalFormat","numberOfMipmapLevels","LINEAR","NEAREST_MIPMAP_LINEAR","idCheck","id","Uint8Array","i","console","error","size","Uint32Array","BYTES_PER_ELEMENT","head","DataView","littleEndian","getUint32","glType","warn","width","height","numberOfFaces","Math","max","bytesOfKeyValueData","offset","level","levelSize","Int32Array","face","data","push"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/KTXTexture.js"],"sourcesContent":["import { Texture } from '../core/Texture.js';\n\n// TODO: Support cubemaps\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nexport class KTXTexture extends Texture {\n    constructor(gl, { buffer, wrapS = gl.CLAMP_TO_EDGE, wrapT = gl.CLAMP_TO_EDGE, anisotropy = 0, minFilter, magFilter } = {}) {\n        super(gl, {\n            generateMipmaps: false,\n            wrapS,\n            wrapT,\n            anisotropy,\n            minFilter,\n            magFilter,\n        });\n\n        if (buffer) return this.parseBuffer(buffer);\n    }\n\n    parseBuffer(buffer) {\n        const ktx = new KhronosTextureContainer(buffer);\n        ktx.mipmaps.isCompressedTexture = true;\n\n        // Update texture\n        this.image = ktx.mipmaps;\n        this.internalFormat = ktx.glInternalFormat;\n        if (ktx.numberOfMipmapLevels > 1) {\n            if (this.minFilter === this.gl.LINEAR) this.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        } else {\n            if (this.minFilter === this.gl.NEAREST_MIPMAP_LINEAR) this.minFilter = this.gl.LINEAR;\n        }\n\n        // TODO: support cube maps\n        // ktx.numberOfFaces\n    }\n}\n\nfunction KhronosTextureContainer(buffer) {\n    const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n    const id = new Uint8Array(buffer, 0, 12);\n    for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) return console.error('File missing KTX identifier');\n\n    // TODO: Is this always 4? Tested: [android, macos]\n    const size = Uint32Array.BYTES_PER_ELEMENT;\n    const head = new DataView(buffer, 12, 13 * size);\n    const littleEndian = head.getUint32(0, true) === 0x04030201;\n    const glType = head.getUint32(1 * size, littleEndian);\n    if (glType !== 0) return console.warn('only compressed formats currently supported');\n    this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n    let width = head.getUint32(6 * size, littleEndian);\n    let height = head.getUint32(7 * size, littleEndian);\n    this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n    this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n    const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n\n    this.mipmaps = [];\n    let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n    for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n        const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n        offset += 4; // levelSize field\n        for (let face = 0; face < this.numberOfFaces; face++) {\n            const data = new Uint8Array(buffer, offset, levelSize);\n            this.mipmaps.push({ data, width, height });\n            offset += levelSize;\n            offset += 3 - ((levelSize + 3) % 4); // add padding for odd sized image\n        }\n        width = width >> 1;\n        height = height >> 1;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}