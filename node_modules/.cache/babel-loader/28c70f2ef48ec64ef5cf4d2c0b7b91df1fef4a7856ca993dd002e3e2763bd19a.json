{"ast":null,"code":"export function Text(_ref) {\n  let {\n    font,\n    text,\n    width = Infinity,\n    align = 'left',\n    size = 1,\n    letterSpacing = 0,\n    lineHeight = 1.4,\n    wordSpacing = 0,\n    wordBreak = false\n  } = _ref;\n  const _this = this;\n  let glyphs, buffers;\n  let fontHeight, baseline, scale;\n  const newline = /\\n/;\n  const whitespace = /\\s/;\n  {\n    parseFont();\n    createGeometry();\n  }\n  function parseFont() {\n    glyphs = {};\n    font.chars.forEach(d => glyphs[d.char] = d);\n  }\n  function createGeometry() {\n    fontHeight = font.common.lineHeight;\n    baseline = font.common.base;\n\n    // Use baseline so that actual text height is as close to 'size' value as possible\n    scale = size / baseline;\n\n    // Strip spaces and newlines to get actual character length for buffers\n    let chars = text.replace(/[ \\n]/g, '');\n    let numChars = chars.length;\n\n    // Create output buffers\n    buffers = {\n      position: new Float32Array(numChars * 4 * 3),\n      uv: new Float32Array(numChars * 4 * 2),\n      id: new Float32Array(numChars * 4),\n      index: new Uint16Array(numChars * 6)\n    };\n\n    // Set values for buffers that don't require calculation\n    for (let i = 0; i < numChars; i++) {\n      buffers.id.set([i, i, i, i], i * 4);\n      buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n    }\n    layout();\n  }\n  function layout() {\n    const lines = [];\n    let cursor = 0;\n    let wordCursor = 0;\n    let wordWidth = 0;\n    let line = newLine();\n    function newLine() {\n      const line = {\n        width: 0,\n        glyphs: []\n      };\n      lines.push(line);\n      wordCursor = cursor;\n      wordWidth = 0;\n      return line;\n    }\n    let maxTimes = 100;\n    let count = 0;\n    while (cursor < text.length && count < maxTimes) {\n      count++;\n      const char = text[cursor];\n\n      // Skip whitespace at start of line\n      if (!line.width && whitespace.test(char)) {\n        cursor++;\n        wordCursor = cursor;\n        wordWidth = 0;\n        continue;\n      }\n\n      // If newline char, skip to next line\n      if (newline.test(char)) {\n        cursor++;\n        line = newLine();\n        continue;\n      }\n      const glyph = glyphs[char] || glyphs[' '];\n\n      // Find any applicable kern pairs\n      if (line.glyphs.length) {\n        const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n        let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n        line.width += kern;\n        wordWidth += kern;\n      }\n\n      // add char to line\n      line.glyphs.push([glyph, line.width]);\n\n      // calculate advance for next glyph\n      let advance = 0;\n\n      // If whitespace, update location of current word for line breaks\n      if (whitespace.test(char)) {\n        wordCursor = cursor;\n        wordWidth = 0;\n\n        // Add wordspacing\n        advance += wordSpacing * size;\n      } else {\n        // Add letterspacing\n        advance += letterSpacing * size;\n      }\n      advance += glyph.xadvance * scale;\n      line.width += advance;\n      wordWidth += advance;\n\n      // If width defined\n      if (line.width > width) {\n        // If can break words, undo latest glyph if line not empty and create new line\n        if (wordBreak && line.glyphs.length > 1) {\n          line.width -= advance;\n          line.glyphs.pop();\n          line = newLine();\n          continue;\n\n          // If not first word, undo current word and cursor and create new line\n        } else if (!wordBreak && wordWidth !== line.width) {\n          let numGlyphs = cursor - wordCursor + 1;\n          line.glyphs.splice(-numGlyphs, numGlyphs);\n          cursor = wordCursor;\n          line.width -= wordWidth;\n          line = newLine();\n          continue;\n        }\n      }\n      cursor++;\n      // Reset infinite loop catch\n      count = 0;\n    }\n\n    // Remove last line if empty\n    if (!line.width) lines.pop();\n    populateBuffers(lines);\n  }\n  function populateBuffers(lines) {\n    const texW = font.common.scaleW;\n    const texH = font.common.scaleH;\n\n    // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n    let y = 0.07 * size;\n    let j = 0;\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      let line = lines[lineIndex];\n      for (let i = 0; i < line.glyphs.length; i++) {\n        const glyph = line.glyphs[i][0];\n        let x = line.glyphs[i][1];\n        if (align === 'center') {\n          x -= line.width * 0.5;\n        } else if (align === 'right') {\n          x -= line.width;\n        }\n\n        // If space, don't add to geometry\n        if (whitespace.test(glyph.char)) continue;\n\n        // Apply char sprite offsets\n        x += glyph.xoffset * scale;\n        y -= glyph.yoffset * scale;\n\n        // each letter is a quad. axis bottom left\n        let w = glyph.width * scale;\n        let h = glyph.height * scale;\n        buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n        let u = glyph.x / texW;\n        let uw = glyph.width / texW;\n        let v = 1.0 - glyph.y / texH;\n        let vh = glyph.height / texH;\n        buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);\n\n        // Reset cursor to baseline\n        y += glyph.yoffset * scale;\n        j++;\n      }\n      y -= size * lineHeight;\n    }\n    _this.buffers = buffers;\n    _this.numLines = lines.length;\n    _this.height = _this.numLines * size * lineHeight;\n    _this.width = Math.max(...lines.map(line => line.width));\n  }\n  function getKernPairOffset(id1, id2) {\n    for (let i = 0; i < font.kernings.length; i++) {\n      let k = font.kernings[i];\n      if (k.first < id1) continue;\n      if (k.second < id2) continue;\n      if (k.first > id1) return 0;\n      if (k.first === id1 && k.second > id2) return 0;\n      return k.amount;\n    }\n    return 0;\n  }\n\n  // Update buffers to layout with new layout\n  this.resize = function (options) {\n    ({\n      width\n    } = options);\n    layout();\n  };\n\n  // Completely change text (like creating new Text)\n  this.update = function (options) {\n    ({\n      text\n    } = options);\n    createGeometry();\n  };\n}","map":{"version":3,"names":["Text","_ref","font","text","width","Infinity","align","size","letterSpacing","lineHeight","wordSpacing","wordBreak","_this","glyphs","buffers","fontHeight","baseline","scale","newline","whitespace","parseFont","createGeometry","chars","forEach","d","char","common","base","replace","numChars","length","position","Float32Array","uv","id","index","Uint16Array","i","set","layout","lines","cursor","wordCursor","wordWidth","line","newLine","push","maxTimes","count","test","glyph","prevGlyph","kern","getKernPairOffset","advance","xadvance","pop","numGlyphs","splice","populateBuffers","texW","scaleW","texH","scaleH","y","j","lineIndex","x","xoffset","yoffset","w","h","height","u","uw","v","vh","numLines","Math","max","map","id1","id2","kernings","k","first","second","amount","resize","options","update"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/Text.js"],"sourcesContent":["export function Text({\n    font,\n    text,\n    width = Infinity,\n    align = 'left',\n    size = 1,\n    letterSpacing = 0,\n    lineHeight = 1.4,\n    wordSpacing = 0,\n    wordBreak = false,\n}) {\n    const _this = this;\n    let glyphs, buffers;\n    let fontHeight, baseline, scale;\n\n    const newline = /\\n/;\n    const whitespace = /\\s/;\n\n    {\n        parseFont();\n        createGeometry();\n    }\n\n    function parseFont() {\n        glyphs = {};\n        font.chars.forEach((d) => (glyphs[d.char] = d));\n    }\n\n    function createGeometry() {\n        fontHeight = font.common.lineHeight;\n        baseline = font.common.base;\n\n        // Use baseline so that actual text height is as close to 'size' value as possible\n        scale = size / baseline;\n\n        // Strip spaces and newlines to get actual character length for buffers\n        let chars = text.replace(/[ \\n]/g, '');\n        let numChars = chars.length;\n\n        // Create output buffers\n        buffers = {\n            position: new Float32Array(numChars * 4 * 3),\n            uv: new Float32Array(numChars * 4 * 2),\n            id: new Float32Array(numChars * 4),\n            index: new Uint16Array(numChars * 6),\n        };\n\n        // Set values for buffers that don't require calculation\n        for (let i = 0; i < numChars; i++) {\n            buffers.id.set([i, i, i, i], i * 4);\n            buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n        }\n\n        layout();\n    }\n\n    function layout() {\n        const lines = [];\n\n        let cursor = 0;\n\n        let wordCursor = 0;\n        let wordWidth = 0;\n        let line = newLine();\n\n        function newLine() {\n            const line = {\n                width: 0,\n                glyphs: [],\n            };\n            lines.push(line);\n            wordCursor = cursor;\n            wordWidth = 0;\n            return line;\n        }\n\n        let maxTimes = 100;\n        let count = 0;\n        while (cursor < text.length && count < maxTimes) {\n            count++;\n\n            const char = text[cursor];\n\n            // Skip whitespace at start of line\n            if (!line.width && whitespace.test(char)) {\n                cursor++;\n                wordCursor = cursor;\n                wordWidth = 0;\n                continue;\n            }\n\n            // If newline char, skip to next line\n            if (newline.test(char)) {\n                cursor++;\n                line = newLine();\n                continue;\n            }\n\n            const glyph = glyphs[char] || glyphs[' '];\n\n            // Find any applicable kern pairs\n            if (line.glyphs.length) {\n                const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n                let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n                line.width += kern;\n                wordWidth += kern;\n            }\n\n            // add char to line\n            line.glyphs.push([glyph, line.width]);\n\n            // calculate advance for next glyph\n            let advance = 0;\n\n            // If whitespace, update location of current word for line breaks\n            if (whitespace.test(char)) {\n                wordCursor = cursor;\n                wordWidth = 0;\n\n                // Add wordspacing\n                advance += wordSpacing * size;\n            } else {\n                // Add letterspacing\n                advance += letterSpacing * size;\n            }\n\n            advance += glyph.xadvance * scale;\n\n            line.width += advance;\n            wordWidth += advance;\n\n            // If width defined\n            if (line.width > width) {\n                // If can break words, undo latest glyph if line not empty and create new line\n                if (wordBreak && line.glyphs.length > 1) {\n                    line.width -= advance;\n                    line.glyphs.pop();\n                    line = newLine();\n                    continue;\n\n                    // If not first word, undo current word and cursor and create new line\n                } else if (!wordBreak && wordWidth !== line.width) {\n                    let numGlyphs = cursor - wordCursor + 1;\n                    line.glyphs.splice(-numGlyphs, numGlyphs);\n                    cursor = wordCursor;\n                    line.width -= wordWidth;\n                    line = newLine();\n                    continue;\n                }\n            }\n\n            cursor++;\n            // Reset infinite loop catch\n            count = 0;\n        }\n\n        // Remove last line if empty\n        if (!line.width) lines.pop();\n\n        populateBuffers(lines);\n    }\n\n    function populateBuffers(lines) {\n        const texW = font.common.scaleW;\n        const texH = font.common.scaleH;\n\n        // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n        let y = 0.07 * size;\n        let j = 0;\n\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n            let line = lines[lineIndex];\n\n            for (let i = 0; i < line.glyphs.length; i++) {\n                const glyph = line.glyphs[i][0];\n                let x = line.glyphs[i][1];\n\n                if (align === 'center') {\n                    x -= line.width * 0.5;\n                } else if (align === 'right') {\n                    x -= line.width;\n                }\n\n                // If space, don't add to geometry\n                if (whitespace.test(glyph.char)) continue;\n\n                // Apply char sprite offsets\n                x += glyph.xoffset * scale;\n                y -= glyph.yoffset * scale;\n\n                // each letter is a quad. axis bottom left\n                let w = glyph.width * scale;\n                let h = glyph.height * scale;\n                buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n\n                let u = glyph.x / texW;\n                let uw = glyph.width / texW;\n                let v = 1.0 - glyph.y / texH;\n                let vh = glyph.height / texH;\n                buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);\n\n                // Reset cursor to baseline\n                y += glyph.yoffset * scale;\n\n                j++;\n            }\n\n            y -= size * lineHeight;\n        }\n\n        _this.buffers = buffers;\n        _this.numLines = lines.length;\n        _this.height = _this.numLines * size * lineHeight;\n        _this.width = Math.max(...lines.map((line) => line.width));\n    }\n\n    function getKernPairOffset(id1, id2) {\n        for (let i = 0; i < font.kernings.length; i++) {\n            let k = font.kernings[i];\n            if (k.first < id1) continue;\n            if (k.second < id2) continue;\n            if (k.first > id1) return 0;\n            if (k.first === id1 && k.second > id2) return 0;\n            return k.amount;\n        }\n        return 0;\n    }\n\n    // Update buffers to layout with new layout\n    this.resize = function (options) {\n        ({ width } = options);\n        layout();\n    };\n\n    // Completely change text (like creating new Text)\n    this.update = function (options) {\n        ({ text } = options);\n        createGeometry();\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}