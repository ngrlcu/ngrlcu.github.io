{"ast":null,"code":"import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\nexport class GPGPU {\n  constructor(gl, _ref) {\n    let {\n      // Always pass in array of vec4s (RGBA values within texture)\n      data = new Float32Array(16),\n      geometry = new Triangle(gl),\n      type // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n    } = _ref;\n    this.gl = gl;\n    const initialData = data;\n    this.passes = [];\n    this.geometry = geometry;\n    this.dataLength = initialData.length / 4;\n\n    // Windows and iOS only like power of 2 textures\n    // Find smallest PO2 that fits data\n    this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n    // Create coords for output texture\n    this.coords = new Float32Array(this.dataLength * 2);\n    for (let i = 0; i < this.dataLength; i++) {\n      const x = i % this.size / this.size; // to add 0.5 to be center pixel ?\n      const y = Math.floor(i / this.size) / this.size;\n      this.coords.set([x, y], i * 2);\n    }\n\n    // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n    const floatArray = (() => {\n      if (initialData.length === this.size * this.size * 4) {\n        return initialData;\n      } else {\n        const a = new Float32Array(this.size * this.size * 4);\n        a.set(initialData);\n        return a;\n      }\n    })();\n\n    // Create output texture uniform using input float texture with initial data\n    this.uniform = {\n      value: new Texture(gl, {\n        image: floatArray,\n        target: gl.TEXTURE_2D,\n        type: gl.FLOAT,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        generateMipmaps: false,\n        minFilter: gl.NEAREST,\n        magFilter: gl.NEAREST,\n        width: this.size,\n        flipY: false\n      })\n    };\n\n    // Create FBOs\n    const options = {\n      width: this.size,\n      height: this.size,\n      type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n      format: gl.RGBA,\n      internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n      minFilter: gl.NEAREST,\n      depth: false,\n      unpackAlignment: 1\n    };\n    this.fbo = {\n      read: new RenderTarget(gl, options),\n      write: new RenderTarget(gl, options),\n      swap: () => {\n        let temp = this.fbo.read;\n        this.fbo.read = this.fbo.write;\n        this.fbo.write = temp;\n        this.uniform.value = this.fbo.read.texture;\n      }\n    };\n  }\n  addPass() {\n    let {\n      vertex = defaultVertex,\n      fragment = defaultFragment,\n      uniforms = {},\n      textureUniform = 'tMap',\n      enabled = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    uniforms[textureUniform] = this.uniform;\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n  render() {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    enabledPasses.forEach((pass, i) => {\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: this.fbo.write,\n        clear: false\n      });\n      this.fbo.swap();\n    });\n  }\n}\nconst defaultVertex = /* glsl */\"\\n    attribute vec2 uv;\\n    attribute vec2 position;\\n\\n    varying vec2 vUv;\\n\\n    void main() {\\n        vUv = uv;\\n        gl_Position = vec4(position, 0, 1);\\n    }\\n\";\nconst defaultFragment = /* glsl */\"\\n    precision highp float;\\n\\n    uniform sampler2D tMap;\\n    varying vec2 vUv;\\n\\n    void main() {\\n        gl_FragColor = texture2D(tMap, vUv);\\n    }\\n\";","map":{"version":3,"names":["Program","Mesh","Texture","RenderTarget","Triangle","GPGPU","constructor","gl","_ref","data","Float32Array","geometry","type","initialData","passes","dataLength","length","size","Math","pow","ceil","log","sqrt","LN2","coords","i","x","y","floor","set","floatArray","a","uniform","value","image","target","TEXTURE_2D","FLOAT","format","RGBA","internalFormat","renderer","isWebgl2","RGBA32F","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmaps","minFilter","NEAREST","magFilter","width","flipY","options","height","HALF_FLOAT","extensions","HALF_FLOAT_OES","RGBA16F","depth","unpackAlignment","fbo","read","write","swap","temp","texture","addPass","vertex","defaultVertex","fragment","defaultFragment","uniforms","textureUniform","enabled","arguments","undefined","program","mesh","pass","push","render","enabledPasses","filter","forEach","scene","clear"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/GPGPU.js"],"sourcesContent":["import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class GPGPU {\n    constructor(\n        gl,\n        {\n            // Always pass in array of vec4s (RGBA values within texture)\n            data = new Float32Array(16),\n            geometry = new Triangle(gl),\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        }\n    ) {\n        this.gl = gl;\n        const initialData = data;\n        this.passes = [];\n        this.geometry = geometry;\n        this.dataLength = initialData.length / 4;\n\n        // Windows and iOS only like power of 2 textures\n        // Find smallest PO2 that fits data\n        this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n        // Create coords for output texture\n        this.coords = new Float32Array(this.dataLength * 2);\n        for (let i = 0; i < this.dataLength; i++) {\n            const x = (i % this.size) / this.size; // to add 0.5 to be center pixel ?\n            const y = Math.floor(i / this.size) / this.size;\n            this.coords.set([x, y], i * 2);\n        }\n\n        // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n        const floatArray = (() => {\n            if (initialData.length === this.size * this.size * 4) {\n                return initialData;\n            } else {\n                const a = new Float32Array(this.size * this.size * 4);\n                a.set(initialData);\n                return a;\n            }\n        })();\n\n        // Create output texture uniform using input float texture with initial data\n        this.uniform = {\n            value: new Texture(gl, {\n                image: floatArray,\n                target: gl.TEXTURE_2D,\n                type: gl.FLOAT,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n                wrapS: gl.CLAMP_TO_EDGE,\n                wrapT: gl.CLAMP_TO_EDGE,\n                generateMipmaps: false,\n                minFilter: gl.NEAREST,\n                magFilter: gl.NEAREST,\n                width: this.size,\n                flipY: false,\n            }),\n        };\n\n        // Create FBOs\n        const options = {\n            width: this.size,\n            height: this.size,\n            type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n            format: gl.RGBA,\n            internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n            minFilter: gl.NEAREST,\n            depth: false,\n            unpackAlignment: 1,\n        };\n\n        this.fbo = {\n            read: new RenderTarget(gl, options),\n            write: new RenderTarget(gl, options),\n            swap: () => {\n                let temp = this.fbo.read;\n                this.fbo.read = this.fbo.write;\n                this.fbo.write = temp;\n                this.uniform.value = this.fbo.read.texture;\n            },\n        };\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = this.uniform;\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    render() {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        enabledPasses.forEach((pass, i) => {\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: this.fbo.write,\n                clear: false,\n            });\n            this.fbo.swap();\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}