{"ast":null,"code":"import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nconst tmpVec3A = /* @__PURE__ */new Vec3();\nconst tmpVec3B = /* @__PURE__ */new Vec3();\nconst tmpVec3C = /* @__PURE__ */new Vec3();\nconst tmpVec3D = /* @__PURE__ */new Vec3();\nconst tmpQuatA = /* @__PURE__ */new Quat();\nconst tmpQuatB = /* @__PURE__ */new Quat();\nconst tmpQuatC = /* @__PURE__ */new Quat();\nconst tmpQuatD = /* @__PURE__ */new Quat();\nexport class GLTFAnimation {\n  constructor(data) {\n    let weight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight;\n\n    // Set to false to not apply modulo to elapsed against duration\n    this.loop = true;\n\n    // Find starting time as exports from blender (perhaps others too) don't always start from 0\n    this.startTime = data.reduce((a, _ref) => {\n      let {\n        times\n      } = _ref;\n      return Math.min(a, times[0]);\n    }, Infinity);\n    // Get largest final time in all channels to calculate duration\n    this.endTime = data.reduce((a, _ref2) => {\n      let {\n        times\n      } = _ref2;\n      return Math.max(a, times[times.length - 1]);\n    }, 0);\n    this.duration = this.endTime - this.startTime;\n  }\n  update() {\n    let totalWeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let isSet = arguments.length > 1 ? arguments[1] : undefined;\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = !this.duration ? 0 : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n    this.data.forEach(_ref3 => {\n      let {\n        node,\n        transform,\n        interpolation,\n        times,\n        values\n      } = _ref3;\n      if (!this.duration) {\n        let val = tmpVec3A;\n        let size = 3;\n        if (transform === 'quaternion') {\n          val = tmpQuatA;\n          size = 4;\n        }\n        val.fromArray(values, 0);\n        if (size === 4) node[transform].slerp(val, weight);else node[transform].lerp(val, weight);\n        return;\n      }\n\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1;\n\n      // Get linear blend/alpha between the two\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n        // interpolate for final value\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size);\n\n        // interpolate for final value\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      }\n\n      // interpolate between multiple possible animations\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n    return prevVal;\n  }\n}","map":{"version":3,"names":["Vec3","Quat","tmpVec3A","tmpVec3B","tmpVec3C","tmpVec3D","tmpQuatA","tmpQuatB","tmpQuatC","tmpQuatD","GLTFAnimation","constructor","data","weight","arguments","length","undefined","elapsed","loop","startTime","reduce","a","_ref","times","Math","min","Infinity","endTime","_ref2","max","duration","update","totalWeight","isSet","forEach","_ref3","node","transform","interpolation","values","val","size","fromArray","slerp","lerp","prevIndex","findIndex","t","nextIndex","alpha","prevVal","prevTan","nextTan","nextVal","cubicSplineInterpolate","normalize","t2","t3","s2","s3","s0","s1","i"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/GLTFAnimation.js"],"sourcesContent":["import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}