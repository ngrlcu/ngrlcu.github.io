{"ast":null,"code":"// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\nlet ID = 1;\nexport class Texture {\n  constructor(gl) {\n    let {\n      image,\n      target = gl.TEXTURE_2D,\n      type = gl.UNSIGNED_BYTE,\n      format = gl.RGBA,\n      internalFormat = format,\n      wrapS = gl.CLAMP_TO_EDGE,\n      wrapT = gl.CLAMP_TO_EDGE,\n      wrapR = gl.CLAMP_TO_EDGE,\n      generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n      minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n      magFilter = gl.LINEAR,\n      premultiplyAlpha = false,\n      unpackAlignment = 4,\n      flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n      anisotropy = 0,\n      level = 0,\n      width,\n      // used for RenderTargets or Data Textures\n      height = width,\n      length = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = ID++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.wrapR = wrapR;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.length = length;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    };\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // State store to avoid redundant calls for per-texture state\n    this.state = {};\n    this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    this.state.magFilter = this.gl.LINEAR;\n    this.state.wrapS = this.gl.REPEAT;\n    this.state.wrapT = this.gl.REPEAT;\n    this.state.anisotropy = 0;\n  }\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n  update() {\n    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n    // Make sure that texture is bound to its texture unit\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n    if (this.wrapR !== this.state.wrapR) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n      this.state.wrapR = this.wrapR;\n    }\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n        } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n        }\n      } else if (this.image.isCompressedTexture) {\n        // Compressed texture\n        for (let level = 0; level < this.image.length; level++) {\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n        }\n      } else {\n        // Regular texture\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n        } else {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n        }\n      }\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      }\n\n      // Callback for when data is pushed to GPU\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        if (this.target === this.gl.TEXTURE_2D) {\n          this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n        } else {\n          this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n        }\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n    this.store.image = this.image;\n  }\n}","map":{"version":3,"names":["emptyPixel","Uint8Array","isPowerOf2","value","ID","Texture","constructor","gl","image","target","TEXTURE_2D","type","UNSIGNED_BYTE","format","RGBA","internalFormat","wrapS","CLAMP_TO_EDGE","wrapT","wrapR","generateMipmaps","TEXTURE_CUBE_MAP","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","TEXTURE_3D","anisotropy","level","width","height","length","arguments","undefined","id","Math","min","renderer","parameters","maxAnisotropy","texture","createTexture","store","glState","state","REPEAT","bind","textureUnits","activeTextureUnit","bindTexture","update","textureUnit","needsUpdate","activeTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","texParameterf","getExtension","TEXTURE_MAX_ANISOTROPY_EXT","i","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","ArrayBuffer","isView","TEXTURE_2D_ARRAY","texImage3D","isCompressedTexture","compressedTexImage2D","data","isWebgl2","generateMipmap","onUpdate"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/core/Texture.js"],"sourcesContent":["// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}