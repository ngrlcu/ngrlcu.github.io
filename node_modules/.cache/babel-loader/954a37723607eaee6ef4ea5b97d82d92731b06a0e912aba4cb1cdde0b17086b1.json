{"ast":null,"code":"import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\nconst tempVec3 = /* @__PURE__ */new Vec3();\nconst tempMat4 = /* @__PURE__ */new Mat4();\nfunction throwIfNullProperty(property, message) {\n  if (this[property] == null) throw new Error(message);\n}\nexport class Path {\n  constructor() {\n    this._segments = [];\n    this._lengthOffsets = null;\n    this._totalLength = -1;\n    this._lastPoint = null;\n    this._lastTilt = 0;\n    this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n    this.tiltFunction = null;\n  }\n  moveTo(p) {\n    let tilt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._totalLength = -1;\n    this._lastPoint = p;\n    this._lastTilt = tilt;\n  }\n  bezierCurveTo(cp1, cp2, p) {\n    let tilt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this._assertLastPoint();\n    const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  quadraticCurveTo(cp, p) {\n    let tilt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._assertLastPoint();\n    const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  lineTo(p) {\n    let tilt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertLastPoint();\n    const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n    this.addSegment(seg);\n    return this;\n  }\n  addSegment(segment) {\n    this._totalLength = -1;\n    this._lastPoint = segment.lastPoint();\n    this._lastTilt = segment.tiltEnd;\n    this._segments.push(segment);\n    return this;\n  }\n  getSegments() {\n    return this._segments;\n  }\n  updateLength() {\n    const n = this._segments.length;\n    this._lengthOffsets = new Array(n);\n    let offset = 0;\n    for (let i = 0; i < n; i++) {\n      this._lengthOffsets[i] = offset;\n      offset += this._segments[i].getLength();\n    }\n    this._totalLength = offset;\n  }\n  getLength() {\n    if (this._totalLength < 0) {\n      this.updateLength();\n    }\n    return this._totalLength;\n  }\n\n  /**\n   * Finding a path segment at a given absolute length distance\n   * @param {number} len absolute length distance\n   * @returns {[number, number]} [_segment index_, _relative segment distance_]\n   */\n  findSegmentIndexAtLength(len) {\n    const totalLength = this.getLength();\n    if (len <= 0) {\n      return [0, 0];\n    }\n    if (len >= totalLength) {\n      return [this._segments.length - 1, 1];\n    }\n    let start = 0;\n    let end = this._lengthOffsets.length - 1;\n    let index = -1;\n    let mid;\n    while (start <= end) {\n      mid = Math.ceil((start + end) / 2);\n      if (mid === 0 || mid === this._lengthOffsets.length - 1 || len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1]) {\n        index = mid;\n        break;\n      } else if (len < this._lengthOffsets[mid]) {\n        end = mid - 1;\n      } else {\n        start = mid + 1;\n      }\n    }\n    const seg = this._segments[index];\n    const segLen = seg.getLength();\n    const t = (len - this._lengthOffsets[index]) / segLen;\n    return [index, t];\n  }\n  getPointAtLength(len) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vec3();\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getPointAt(t, out);\n  }\n  getPointAt(t) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vec3();\n    const totalLength = this.getLength();\n    return this.getPointAtLength(t * totalLength, out);\n  }\n  getTangentAtLength(len) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vec3();\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getTangentAt(t, out);\n  }\n  getTangentAt(t) {\n    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vec3();\n    const totalLength = this.getLength();\n    return this.getTangentAtLength(t * totalLength, out);\n  }\n  getTiltAtLength(len) {\n    const [i, t] = this.findSegmentIndexAtLength(len);\n    return this._segments[i].getTiltAt(t);\n  }\n  getTiltAt(t) {\n    const totalLength = this.getLength();\n    return this.getTiltAtLength(t * totalLength);\n  }\n\n  /**\n   * Get sequence of points using `getPointAt(t)`\n   * @param {number} divisions number of subdivisions\n   * @returns {Vec3[]} array of points\n   */\n  getPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n    const points = new Array(divisions + 1);\n    for (let i = 0; i <= divisions; i++) {\n      points[i] = this.getPointAt(i / divisions);\n    }\n    return points;\n  }\n\n  /**\n   * Generates the Frenet Frames.\n   * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n   * @param {number} divisions number of subdivisions\n   * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n   */\n  computeFrenetFrames() {\n    var _this$tiltFunction;\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n    let closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const tangents = new Array(divisions + 1);\n    const tilts = new Array(divisions + 1);\n    const tiltFunction = (_this$tiltFunction = this.tiltFunction) !== null && _this$tiltFunction !== void 0 ? _this$tiltFunction : a => a;\n\n    // compute the tangent vectors and tilt for each segment on the curve\n    const totalLength = this.getLength();\n    for (let i = 0; i <= divisions; i++) {\n      const [si, st] = this.findSegmentIndexAtLength(totalLength * i / divisions);\n      const segment = this._segments[si];\n      tangents[i] = segment.getTangentAt(st);\n      tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n    }\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    const normal = new Vec3();\n    if (tx < ty && tx < tz) {\n      normal.set(1, 0, 0);\n    } else if (ty < tx && ty < tz) {\n      normal.set(0, 1, 0);\n    } else {\n      normal.set(0, 0, 1);\n    }\n\n    // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n    const normals = new Array(divisions + 1);\n    const binormals = new Array(divisions + 1);\n    normals[0] = new Vec3();\n    binormals[0] = new Vec3();\n    tempVec3.cross(tangents[0], normal).normalize();\n    normals[0].cross(tangents[0], tempVec3);\n    binormals[0].cross(tangents[0], normals[0]);\n\n    // compute the slowly-varying normal vector for each segment on the curve\n    for (let i = 1; i < tangents.length; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = new Vec3();\n      tempVec3.cross(tangents[i - 1], tangents[i]);\n      const crossLen = tempVec3.len();\n      if (crossLen > Number.EPSILON) {\n        tempVec3.scale(1 / crossLen); // nomalize\n        const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n        const sinTheta = clamp(crossLen, -1, 1);\n        mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n        normals[i].applyMatrix4(tempMat4);\n      }\n      binormals[i].cross(tangents[i], normals[i]);\n    }\n\n    // add tilt twisting\n    for (let i = 0; i < tilts.length; i++) {\n      rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n    }\n\n    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n    if (closed === true) {\n      const normalLast = normals[normals.length - 1];\n      let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n      if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n        step = -step;\n      }\n      for (let i = 1; i < normals.length - 1; i++) {\n        const angle = step * i;\n        rotateNormalBinormal(angle, normals[i], binormals[i]);\n        tilts[i] += toDegrees(angle);\n      }\n      normals[normals.length - 1] = normals[0].clone();\n      binormals[binormals.length - 1] = binormals[0].clone();\n    }\n    return {\n      tangents,\n      normals,\n      binormals,\n      tilts\n    };\n  }\n}","map":{"version":3,"names":["Vec3","Mat4","CubicBezierSegment","QuadraticBezierSegment","LineSegment","clamp","toDegrees","toRadian","mat4fromRotationSinCos","rotateNormalBinormal","tempVec3","tempMat4","throwIfNullProperty","property","message","Error","Path","constructor","_segments","_lengthOffsets","_totalLength","_lastPoint","_lastTilt","_assertLastPoint","bind","tiltFunction","moveTo","p","tilt","arguments","length","undefined","bezierCurveTo","cp1","cp2","seg","addSegment","quadraticCurveTo","cp","lineTo","segment","lastPoint","tiltEnd","push","getSegments","updateLength","n","Array","offset","i","getLength","findSegmentIndexAtLength","len","totalLength","start","end","index","mid","Math","ceil","segLen","t","getPointAtLength","out","getPointAt","getTangentAtLength","getTangentAt","getTiltAtLength","getTiltAt","getPoints","divisions","points","computeFrenetFrames","_this$tiltFunction","closed","tangents","tilts","a","si","st","tx","abs","x","ty","y","tz","z","normal","set","normals","binormals","cross","normalize","clone","crossLen","Number","EPSILON","scale","cosTheta","dot","sinTheta","applyMatrix4","normalLast","step","acos","angle"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/path/Path.js"],"sourcesContent":["import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nfunction throwIfNullProperty(property, message) {\n    if (this[property] == null) throw new Error(message);\n}\n\nexport class Path {\n    constructor() {\n        this._segments = [];\n        this._lengthOffsets = null;\n        this._totalLength = -1;\n        this._lastPoint = null;\n        this._lastTilt = 0;\n\n        this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n\n        this.tiltFunction = null;\n    }\n\n    moveTo(p, tilt = 0) {\n        this._totalLength = -1;\n        this._lastPoint = p;\n        this._lastTilt = tilt;\n    }\n\n    bezierCurveTo(cp1, cp2, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    quadraticCurveTo(cp, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    lineTo(p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    addSegment(segment) {\n        this._totalLength = -1;\n        this._lastPoint = segment.lastPoint();\n        this._lastTilt = segment.tiltEnd;\n        this._segments.push(segment);\n        return this;\n    }\n\n    getSegments() {\n        return this._segments;\n    }\n\n    updateLength() {\n        const n = this._segments.length;\n        this._lengthOffsets = new Array(n);\n\n        let offset = 0;\n        for (let i = 0; i < n; i++) {\n            this._lengthOffsets[i] = offset;\n            offset += this._segments[i].getLength();\n        }\n\n        this._totalLength = offset;\n    }\n\n    getLength() {\n        if (this._totalLength < 0) {\n            this.updateLength();\n        }\n\n        return this._totalLength;\n    }\n\n    /**\n     * Finding a path segment at a given absolute length distance\n     * @param {number} len absolute length distance\n     * @returns {[number, number]} [_segment index_, _relative segment distance_]\n     */\n    findSegmentIndexAtLength(len) {\n        const totalLength = this.getLength();\n\n        if (len <= 0) {\n            return [0, 0];\n        }\n\n        if (len >= totalLength) {\n            return [this._segments.length - 1, 1];\n        }\n\n        let start = 0;\n        let end = this._lengthOffsets.length - 1;\n        let index = -1;\n        let mid;\n\n        while (start <= end) {\n            mid = Math.ceil((start + end) / 2);\n\n            if (mid === 0 || mid === this._lengthOffsets.length - 1 || (len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1])) {\n                index = mid;\n                break;\n            } else if (len < this._lengthOffsets[mid]) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        const seg = this._segments[index];\n        const segLen = seg.getLength();\n        const t = (len - this._lengthOffsets[index]) / segLen;\n\n        return [index, t];\n    }\n\n    getPointAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getPointAt(t, out);\n    }\n\n    getPointAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getPointAtLength(t * totalLength, out);\n    }\n\n    getTangentAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTangentAt(t, out);\n    }\n\n    getTangentAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getTangentAtLength(t * totalLength, out);\n    }\n\n    getTiltAtLength(len) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTiltAt(t);\n    }\n\n    getTiltAt(t) {\n        const totalLength = this.getLength();\n        return this.getTiltAtLength(t * totalLength);\n    }\n\n    /**\n     * Get sequence of points using `getPointAt(t)`\n     * @param {number} divisions number of subdivisions\n     * @returns {Vec3[]} array of points\n     */\n    getPoints(divisions = 64) {\n        const points = new Array(divisions + 1);\n        for (let i = 0; i <= divisions; i++) {\n            points[i] = this.getPointAt(i / divisions);\n        }\n        return points;\n    }\n\n    /**\n     * Generates the Frenet Frames.\n     * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n     * @param {number} divisions number of subdivisions\n     * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n     */\n    computeFrenetFrames(divisions = 64, closed = false) {\n        const tangents = new Array(divisions + 1);\n        const tilts = new Array(divisions + 1);\n\n        const tiltFunction = this.tiltFunction ?? ((a) => a);\n\n        // compute the tangent vectors and tilt for each segment on the curve\n        const totalLength = this.getLength();\n        for (let i = 0; i <= divisions; i++) {\n            const [si, st] = this.findSegmentIndexAtLength((totalLength * i) / divisions);\n            const segment = this._segments[si];\n            tangents[i] = segment.getTangentAt(st);\n            tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n        }\n\n        const tx = Math.abs(tangents[0].x);\n        const ty = Math.abs(tangents[0].y);\n        const tz = Math.abs(tangents[0].z);\n\n        const normal = new Vec3();\n        if (tx < ty && tx < tz) {\n            normal.set(1, 0, 0);\n        } else if (ty < tx && ty < tz) {\n            normal.set(0, 1, 0);\n        } else {\n            normal.set(0, 0, 1);\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n        const normals = new Array(divisions + 1);\n        const binormals = new Array(divisions + 1);\n        normals[0] = new Vec3();\n        binormals[0] = new Vec3();\n\n        tempVec3.cross(tangents[0], normal).normalize();\n        normals[0].cross(tangents[0], tempVec3);\n        binormals[0].cross(tangents[0], normals[0]);\n\n        // compute the slowly-varying normal vector for each segment on the curve\n        for (let i = 1; i < tangents.length; i++) {\n            normals[i] = normals[i - 1].clone();\n            binormals[i] = new Vec3();\n\n            tempVec3.cross(tangents[i - 1], tangents[i]);\n            const crossLen = tempVec3.len();\n\n            if (crossLen > Number.EPSILON) {\n                tempVec3.scale(1 / crossLen); // nomalize\n                const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n                const sinTheta = clamp(crossLen, -1, 1);\n\n                mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n                normals[i].applyMatrix4(tempMat4);\n            }\n\n            binormals[i].cross(tangents[i], normals[i]);\n        }\n\n        // add tilt twisting\n        for (let i = 0; i < tilts.length; i++) {\n            rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n        if (closed === true) {\n            const normalLast = normals[normals.length - 1];\n            let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n\n            if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n                step = -step;\n            }\n\n            for (let i = 1; i < normals.length - 1; i++) {\n                const angle = step * i;\n                rotateNormalBinormal(angle, normals[i], binormals[i]);\n                tilts[i] += toDegrees(angle);\n            }\n\n            normals[normals.length - 1] = normals[0].clone();\n            binormals[binormals.length - 1] = binormals[0].clone();\n        }\n\n        return { tangents, normals, binormals, tilts };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}