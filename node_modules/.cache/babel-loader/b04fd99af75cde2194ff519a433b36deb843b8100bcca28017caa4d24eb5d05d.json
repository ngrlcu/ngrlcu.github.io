{"ast":null,"code":"// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\nconst tempVec3 = /* @__PURE__ */new Vec3();\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nexport class Geometry {\n  constructor(gl) {\n    let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++;\n\n    // Store one VAO per program attribute locations order\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0;\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null;\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // create the buffers\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n  addAttribute(key, attr) {\n    this.attributes[key] = attr;\n\n    // Set options\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n    attr.usage = attr.usage || this.gl.STATIC_DRAW;\n    if (!attr.buffer) {\n      // Push data to buffer\n      this.updateAttribute(attr);\n    }\n\n    // Update geometry counts. If indexed, ignore regular attributes\n    if (attr.divisor) {\n      this.isInstanced = true;\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n  updateAttribute(attr) {\n    const isNewBuffer = !attr.buffer;\n    if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n    if (isNewBuffer) {\n      this.gl.bufferData(attr.target, attr.data, attr.usage);\n    } else {\n      this.gl.bufferSubData(attr.target, 0, attr.data);\n    }\n    attr.needsUpdate = false;\n  }\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, _ref) => {\n      let {\n        name,\n        type\n      } = _ref;\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(\"active attribute \".concat(name, \" not being supplied\"));\n        return;\n      }\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n\n      // For matrix attributes, buffer needs to be defined per column\n      let numLoc = 1;\n      if (type === 35674) numLoc = 2; // mat2\n      if (type === 35675) numLoc = 3; // mat3\n      if (type === 35676) numLoc = 4; // mat4\n\n      const size = attr.size / numLoc;\n      const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n      const offset = numLoc === 1 ? 0 : numLoc * 4;\n      for (let i = 0; i < numLoc; i++) {\n        this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n        this.gl.enableVertexAttribArray(location + i);\n\n        // For instanced attributes, divisor needs to be set.\n        // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n        this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n      }\n    });\n\n    // Bind indices if geometry indexed\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n  draw(_ref2) {\n    var _this$attributes$inde;\n    let {\n      program,\n      mode = this.gl.TRIANGLES\n    } = _ref2;\n    if (this.gl.renderer.currentGeometry !== \"\".concat(this.id, \"_\").concat(program.attributeOrder)) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = \"\".concat(this.id, \"_\").concat(program.attributeOrder);\n    }\n\n    // Check if any attributes need updating\n    program.attributeLocations.forEach((location, _ref3) => {\n      let {\n        name\n      } = _ref3;\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n\n    // For drawElements, offset needs to be multiple of type size\n    let indexBytesPerElement = 2;\n    if (((_this$attributes$inde = this.attributes.index) === null || _this$attributes$inde === void 0 ? void 0 : _this$attributes$inde.type) === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n  getPosition() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position;\n    // if (attr.min) return [...attr.min, ...attr.max];\n    if (attr.data) return attr;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n  computeBoundingBox(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    // Data loaded shouldn't haave stride, only buffers\n    // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n    const stride = attr.size;\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3(),\n        max: new Vec3(),\n        center: new Vec3(),\n        scale: new Vec3(),\n        radius: Infinity\n      };\n    }\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity);\n\n    // TODO: check size of position (eg triangle with Vec2)\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n  computeBoundingSphere(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    // Data loaded shouldn't haave stride, only buffers\n    // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n    const stride = attr.size;\n    if (!this.bounds) this.computeBoundingBox(attr);\n    let maxRadiusSq = 0;\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n  remove() {\n    for (let key in this.VAOs) {\n      this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n      delete this.VAOs[key];\n    }\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n}","map":{"version":3,"names":["Vec3","tempVec3","ID","ATTR_ID","isBoundsWarned","Geometry","constructor","gl","attributes","arguments","length","undefined","canvas","console","error","id","VAOs","drawRange","start","count","instancedCount","renderer","bindVertexArray","currentGeometry","glState","state","key","addAttribute","attr","size","type","data","Float32Array","FLOAT","Uint16Array","UNSIGNED_SHORT","UNSIGNED_INT","target","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","normalized","stride","offset","byteLength","divisor","instanced","needsUpdate","usage","STATIC_DRAW","buffer","updateAttribute","isInstanced","warn","Math","min","index","max","isNewBuffer","createBuffer","boundBuffer","bindBuffer","bufferData","bufferSubData","setIndex","value","setDrawRange","setInstancedCount","createVAO","program","attributeOrder","createVertexArray","bindAttributes","attributeLocations","forEach","location","_ref","name","concat","numLoc","i","vertexAttribPointer","enableVertexAttribArray","vertexAttribDivisor","draw","_ref2","_this$attributes$inde","mode","TRIANGLES","_ref3","indexBytesPerElement","drawElementsInstanced","drawArraysInstanced","drawElements","drawArrays","getPosition","position","computeBoundingBox","array","bounds","center","scale","radius","Infinity","set","l","x","y","z","sub","add","divide","computeBoundingSphere","maxRadiusSq","fromArray","squaredDistance","sqrt","remove","deleteVertexArray","deleteBuffer"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/core/Geometry.js"],"sourcesContent":["// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\n                );\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}