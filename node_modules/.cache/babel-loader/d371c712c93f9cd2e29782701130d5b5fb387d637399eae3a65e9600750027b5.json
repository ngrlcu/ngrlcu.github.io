{"ast":null,"code":"import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\nlet ID = 0;\nexport class Mesh extends Transform {\n  constructor(gl) {\n    let {\n      geometry,\n      program,\n      mode = gl.TRIANGLES,\n      frustumCulled = true,\n      renderOrder = 0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n    this.gl = gl;\n    this.id = ID++;\n    this.geometry = geometry;\n    this.program = program;\n    this.mode = mode;\n\n    // Used to skip frustum culling\n    this.frustumCulled = frustumCulled;\n\n    // Override sorting to force an order\n    this.renderOrder = renderOrder;\n    this.modelViewMatrix = new Mat4();\n    this.normalMatrix = new Mat3();\n    this.beforeRenderCallbacks = [];\n    this.afterRenderCallbacks = [];\n  }\n  onBeforeRender(f) {\n    this.beforeRenderCallbacks.push(f);\n    return this;\n  }\n  onAfterRender(f) {\n    this.afterRenderCallbacks.push(f);\n    return this;\n  }\n  draw() {\n    let {\n      camera\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (camera) {\n      // Add empty matrix uniforms to program if unset\n      if (!this.program.uniforms.modelMatrix) {\n        Object.assign(this.program.uniforms, {\n          modelMatrix: {\n            value: null\n          },\n          viewMatrix: {\n            value: null\n          },\n          modelViewMatrix: {\n            value: null\n          },\n          normalMatrix: {\n            value: null\n          },\n          projectionMatrix: {\n            value: null\n          },\n          cameraPosition: {\n            value: null\n          }\n        });\n      }\n\n      // Set the matrix uniforms\n      this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n      this.program.uniforms.cameraPosition.value = camera.worldPosition;\n      this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n      this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n      this.program.uniforms.modelMatrix.value = this.worldMatrix;\n      this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n      this.program.uniforms.normalMatrix.value = this.normalMatrix;\n    }\n    this.beforeRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    }));\n\n    // determine if faces need to be flipped - when mesh scaled negatively\n    let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n    this.program.use({\n      flipFaces\n    });\n    this.geometry.draw({\n      mode: this.mode,\n      program: this.program\n    });\n    this.afterRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    }));\n  }\n}","map":{"version":3,"names":["Transform","Mat3","Mat4","ID","Mesh","constructor","gl","geometry","program","mode","TRIANGLES","frustumCulled","renderOrder","arguments","length","undefined","canvas","console","error","id","modelViewMatrix","normalMatrix","beforeRenderCallbacks","afterRenderCallbacks","onBeforeRender","f","push","onAfterRender","draw","camera","uniforms","modelMatrix","Object","assign","value","viewMatrix","projectionMatrix","cameraPosition","worldPosition","multiply","worldMatrix","getNormalMatrix","forEach","mesh","flipFaces","cullFace","determinant","use"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/core/Mesh.js"],"sourcesContent":["import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nlet ID = 0;\n\nexport class Mesh extends Transform {\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}) {\n        super();\n        if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n\n    draw({ camera } = {}) {\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: { value: null },\n                    viewMatrix: { value: null },\n                    modelViewMatrix: { value: null },\n                    normalMatrix: { value: null },\n                    projectionMatrix: { value: null },\n                    cameraPosition: { value: null },\n                });\n            }\n\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({ flipFaces });\n        this.geometry.draw({ mode: this.mode, program: this.program });\n        this.afterRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}