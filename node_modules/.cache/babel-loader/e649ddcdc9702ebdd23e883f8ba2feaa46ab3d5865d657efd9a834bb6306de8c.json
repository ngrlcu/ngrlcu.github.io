{"ast":null,"code":"import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nexport class Shadow {\n  constructor(gl, _ref) {\n    let {\n      light = new Camera(gl),\n      width = 1024,\n      height = width\n    } = _ref;\n    this.gl = gl;\n    this.light = light;\n    this.target = new RenderTarget(gl, {\n      width,\n      height\n    });\n    this.targetUniform = {\n      value: this.target.texture\n    };\n    this.depthProgram = new Program(gl, {\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      cullFace: false\n    });\n    this.castMeshes = [];\n  }\n  add(_ref2) {\n    let {\n      mesh,\n      receive = true,\n      cast = true,\n      vertex = defaultVertex,\n      fragment = defaultFragment,\n      uniformProjection = 'shadowProjectionMatrix',\n      uniformView = 'shadowViewMatrix',\n      uniformTexture = 'tShadow'\n    } = _ref2;\n    // Add uniforms to existing program\n    if (receive && !mesh.program.uniforms[uniformProjection]) {\n      mesh.program.uniforms[uniformProjection] = {\n        value: this.light.projectionMatrix\n      };\n      mesh.program.uniforms[uniformView] = {\n        value: this.light.viewMatrix\n      };\n      mesh.program.uniforms[uniformTexture] = this.targetUniform;\n    }\n    if (!cast) return;\n    this.castMeshes.push(mesh);\n\n    // Store program for when switching between depth override\n    mesh.colorProgram = mesh.program;\n\n    // Check if depth program already attached\n    if (mesh.depthProgram) return;\n\n    // Use global depth override if nothing custom passed in\n    if (vertex === defaultVertex && fragment === defaultFragment) {\n      mesh.depthProgram = this.depthProgram;\n      return;\n    }\n\n    // Create custom override program\n    mesh.depthProgram = new Program(this.gl, {\n      vertex,\n      fragment,\n      cullFace: false\n    });\n  }\n  setSize(_ref3) {\n    let {\n      width = 1024,\n      height = width\n    } = _ref3;\n    this.target = new RenderTarget(this.gl, {\n      width,\n      height\n    });\n    this.targetUniform.value = this.target.texture;\n  }\n  render(_ref4) {\n    let {\n      scene\n    } = _ref4;\n    // For depth render, replace program with depth override.\n    // Hide meshes not casting shadows.\n    scene.traverse(node => {\n      if (!node.draw) return;\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.depthProgram;\n      } else {\n        node.isForceVisibility = node.visible;\n        node.visible = false;\n      }\n    });\n\n    // Render the depth shadow map using the light as the camera\n    this.gl.renderer.render({\n      scene,\n      camera: this.light,\n      target: this.target\n    });\n\n    // Then switch the program back to the normal one\n    scene.traverse(node => {\n      if (!node.draw) return;\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.colorProgram;\n      } else {\n        node.visible = node.isForceVisibility;\n      }\n    });\n  }\n}\nconst defaultVertex = /* glsl */\"\\n    attribute vec3 position;\\n    attribute vec2 uv;\\n\\n    uniform mat4 modelViewMatrix;\\n    uniform mat4 projectionMatrix;\\n\\n    void main() {\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n    }\\n\";\nconst defaultFragment = /* glsl */\"\\n    precision highp float;\\n\\n    vec4 packRGBA (float v) {\\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\\n        return pack;\\n    }\\n\\n    void main() {\\n        gl_FragColor = packRGBA(gl_FragCoord.z);\\n    }\\n\";","map":{"version":3,"names":["Camera","Program","RenderTarget","Shadow","constructor","gl","_ref","light","width","height","target","targetUniform","value","texture","depthProgram","vertex","defaultVertex","fragment","defaultFragment","cullFace","castMeshes","add","_ref2","mesh","receive","cast","uniformProjection","uniformView","uniformTexture","program","uniforms","projectionMatrix","viewMatrix","push","colorProgram","setSize","_ref3","render","_ref4","scene","traverse","node","draw","indexOf","isForceVisibility","visible","renderer","camera"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/Shadow.js"],"sourcesContent":["import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\n\nexport class Shadow {\n    constructor(gl, { light = new Camera(gl), width = 1024, height = width }) {\n        this.gl = gl;\n\n        this.light = light;\n\n        this.target = new RenderTarget(gl, { width, height });\n        this.targetUniform = { value: this.target.texture };\n\n        this.depthProgram = new Program(gl, {\n            vertex: defaultVertex,\n            fragment: defaultFragment,\n            cullFace: false,\n        });\n\n        this.castMeshes = [];\n    }\n\n    add({\n        mesh,\n        receive = true,\n        cast = true,\n        vertex = defaultVertex,\n        fragment = defaultFragment,\n        uniformProjection = 'shadowProjectionMatrix',\n        uniformView = 'shadowViewMatrix',\n        uniformTexture = 'tShadow',\n    }) {\n        // Add uniforms to existing program\n        if (receive && !mesh.program.uniforms[uniformProjection]) {\n            mesh.program.uniforms[uniformProjection] = { value: this.light.projectionMatrix };\n            mesh.program.uniforms[uniformView] = { value: this.light.viewMatrix };\n            mesh.program.uniforms[uniformTexture] = this.targetUniform;\n        }\n\n        if (!cast) return;\n        this.castMeshes.push(mesh);\n\n        // Store program for when switching between depth override\n        mesh.colorProgram = mesh.program;\n\n        // Check if depth program already attached\n        if (mesh.depthProgram) return;\n\n        // Use global depth override if nothing custom passed in\n        if (vertex === defaultVertex && fragment === defaultFragment) {\n            mesh.depthProgram = this.depthProgram;\n            return;\n        }\n\n        // Create custom override program\n        mesh.depthProgram = new Program(this.gl, {\n            vertex,\n            fragment,\n            cullFace: false,\n        });\n    }\n\n    setSize({ width = 1024, height = width }) {\n        this.target = new RenderTarget(this.gl, { width, height });\n        this.targetUniform.value = this.target.texture;\n    }\n\n    render({ scene }) {\n        // For depth render, replace program with depth override.\n        // Hide meshes not casting shadows.\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.depthProgram;\n            } else {\n                node.isForceVisibility = node.visible;\n                node.visible = false;\n            }\n        });\n\n        // Render the depth shadow map using the light as the camera\n        this.gl.renderer.render({\n            scene,\n            camera: this.light,\n            target: this.target,\n        });\n\n        // Then switch the program back to the normal one\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.colorProgram;\n            } else {\n                node.visible = node.isForceVisibility;\n            }\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}