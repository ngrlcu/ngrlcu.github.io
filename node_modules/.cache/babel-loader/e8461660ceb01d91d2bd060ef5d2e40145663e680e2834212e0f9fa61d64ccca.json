{"ast":null,"code":"import { Geometry } from '../core/Geometry.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Color } from '../math/Color.js';\nconst tmp = /* @__PURE__ */new Vec3();\nexport class Polyline {\n  constructor(gl, _ref) {\n    let {\n      points,\n      // Array of Vec3s\n      vertex = defaultVertex,\n      fragment = defaultFragment,\n      uniforms = {},\n      attributes = {} // For passing in custom attribs\n    } = _ref;\n    this.gl = gl;\n    this.points = points;\n    this.count = points.length;\n\n    // Create buffers\n    this.position = new Float32Array(this.count * 3 * 2);\n    this.prev = new Float32Array(this.count * 3 * 2);\n    this.next = new Float32Array(this.count * 3 * 2);\n    const side = new Float32Array(this.count * 1 * 2);\n    const uv = new Float32Array(this.count * 2 * 2);\n    const index = new Uint16Array((this.count - 1) * 3 * 2);\n\n    // Set static buffers\n    for (let i = 0; i < this.count; i++) {\n      side.set([-1, 1], i * 2);\n      const v = i / (this.count - 1);\n      uv.set([0, v, 1, v], i * 4);\n      if (i === this.count - 1) continue;\n      const ind = i * 2;\n      index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n      index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n    }\n    const geometry = this.geometry = new Geometry(gl, Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: this.position\n      },\n      prev: {\n        size: 3,\n        data: this.prev\n      },\n      next: {\n        size: 3,\n        data: this.next\n      },\n      side: {\n        size: 1,\n        data: side\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        size: 1,\n        data: index\n      }\n    }));\n\n    // Populate dynamic buffers\n    this.updateGeometry();\n    if (!uniforms.uResolution) this.resolution = uniforms.uResolution = {\n      value: new Vec2()\n    };\n    if (!uniforms.uDPR) this.dpr = uniforms.uDPR = {\n      value: 1\n    };\n    if (!uniforms.uThickness) this.thickness = uniforms.uThickness = {\n      value: 1\n    };\n    if (!uniforms.uColor) this.color = uniforms.uColor = {\n      value: new Color('#000')\n    };\n    if (!uniforms.uMiter) this.miter = uniforms.uMiter = {\n      value: 1\n    };\n\n    // Set size uniforms' values\n    this.resize();\n    const program = this.program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    this.mesh = new Mesh(gl, {\n      geometry,\n      program\n    });\n  }\n  updateGeometry() {\n    this.points.forEach((p, i) => {\n      p.toArray(this.position, i * 3 * 2);\n      p.toArray(this.position, i * 3 * 2 + 3);\n      if (!i) {\n        // If first point, calculate prev using the distance to 2nd point\n        tmp.copy(p).sub(this.points[i + 1]).add(p);\n        tmp.toArray(this.prev, i * 3 * 2);\n        tmp.toArray(this.prev, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.next, (i - 1) * 3 * 2);\n        p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n      }\n      if (i === this.points.length - 1) {\n        // If last point, calculate next using distance to 2nd last point\n        tmp.copy(p).sub(this.points[i - 1]).add(p);\n        tmp.toArray(this.next, i * 3 * 2);\n        tmp.toArray(this.next, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.prev, (i + 1) * 3 * 2);\n        p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n      }\n    });\n    this.geometry.attributes.position.needsUpdate = true;\n    this.geometry.attributes.prev.needsUpdate = true;\n    this.geometry.attributes.next.needsUpdate = true;\n  }\n\n  // Only need to call if not handling resolution uniforms manually\n  resize() {\n    // Update automatic uniforms if not overridden\n    if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n    if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n  }\n}\nconst defaultVertex = /* glsl */\"\\n    precision highp float;\\n\\n    attribute vec3 position;\\n    attribute vec3 next;\\n    attribute vec3 prev;\\n    attribute vec2 uv;\\n    attribute float side;\\n\\n    uniform mat4 modelViewMatrix;\\n    uniform mat4 projectionMatrix;\\n    uniform vec2 uResolution;\\n    uniform float uDPR;\\n    uniform float uThickness;\\n    uniform float uMiter;\\n\\n    varying vec2 vUv;\\n\\n    vec4 getPosition() {\\n        mat4 mvp = projectionMatrix * modelViewMatrix;\\n        vec4 current = mvp * vec4(position, 1);\\n        vec4 nextPos = mvp * vec4(next, 1);\\n        vec4 prevPos = mvp * vec4(prev, 1);\\n\\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \\n        vec2 currentScreen = current.xy / current.w * aspect;\\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\\n    \\n        vec2 dir1 = normalize(currentScreen - prevScreen);\\n        vec2 dir2 = normalize(nextScreen - currentScreen);\\n        vec2 dir = normalize(dir1 + dir2);\\n    \\n        vec2 normal = vec2(-dir.y, dir.x);\\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\\n        normal /= aspect;\\n\\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\\n        float pixelWidth = current.w * pixelWidthRatio;\\n        normal *= pixelWidth * uThickness;\\n        current.xy -= normal * side;\\n    \\n        return current;\\n    }\\n\\n    void main() {\\n        vUv = uv;\\n        gl_Position = getPosition();\\n    }\\n\";\nconst defaultFragment = /* glsl */\"\\n    precision highp float;\\n\\n    uniform vec3 uColor;\\n    \\n    varying vec2 vUv;\\n\\n    void main() {\\n        gl_FragColor.rgb = uColor;\\n        gl_FragColor.a = 1.0;\\n    }\\n\";","map":{"version":3,"names":["Geometry","Program","Mesh","Vec2","Vec3","Color","tmp","Polyline","constructor","gl","_ref","points","vertex","defaultVertex","fragment","defaultFragment","uniforms","attributes","count","length","position","Float32Array","prev","next","side","uv","index","Uint16Array","i","set","v","ind","geometry","Object","assign","size","data","updateGeometry","uResolution","resolution","value","uDPR","dpr","uThickness","thickness","uColor","color","uMiter","miter","resize","program","mesh","forEach","p","toArray","copy","sub","add","needsUpdate","canvas","width","height","renderer"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/Polyline.js"],"sourcesContent":["import { Geometry } from '../core/Geometry.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Color } from '../math/Color.js';\n\nconst tmp = /* @__PURE__ */ new Vec3();\n\nexport class Polyline {\n    constructor(\n        gl,\n        {\n            points, // Array of Vec3s\n            vertex = defaultVertex,\n            fragment = defaultFragment,\n            uniforms = {},\n            attributes = {}, // For passing in custom attribs\n        }\n    ) {\n        this.gl = gl;\n        this.points = points;\n        this.count = points.length;\n\n        // Create buffers\n        this.position = new Float32Array(this.count * 3 * 2);\n        this.prev = new Float32Array(this.count * 3 * 2);\n        this.next = new Float32Array(this.count * 3 * 2);\n        const side = new Float32Array(this.count * 1 * 2);\n        const uv = new Float32Array(this.count * 2 * 2);\n        const index = new Uint16Array((this.count - 1) * 3 * 2);\n\n        // Set static buffers\n        for (let i = 0; i < this.count; i++) {\n            side.set([-1, 1], i * 2);\n            const v = i / (this.count - 1);\n            uv.set([0, v, 1, v], i * 4);\n\n            if (i === this.count - 1) continue;\n            const ind = i * 2;\n            index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n            index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n        }\n\n        const geometry = (this.geometry = new Geometry(\n            gl,\n            Object.assign(attributes, {\n                position: { size: 3, data: this.position },\n                prev: { size: 3, data: this.prev },\n                next: { size: 3, data: this.next },\n                side: { size: 1, data: side },\n                uv: { size: 2, data: uv },\n                index: { size: 1, data: index },\n            })\n        ));\n\n        // Populate dynamic buffers\n        this.updateGeometry();\n\n        if (!uniforms.uResolution) this.resolution = uniforms.uResolution = { value: new Vec2() };\n        if (!uniforms.uDPR) this.dpr = uniforms.uDPR = { value: 1 };\n        if (!uniforms.uThickness) this.thickness = uniforms.uThickness = { value: 1 };\n        if (!uniforms.uColor) this.color = uniforms.uColor = { value: new Color('#000') };\n        if (!uniforms.uMiter) this.miter = uniforms.uMiter = { value: 1 };\n\n        // Set size uniforms' values\n        this.resize();\n\n        const program = (this.program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms,\n        }));\n\n        this.mesh = new Mesh(gl, { geometry, program });\n    }\n\n    updateGeometry() {\n        this.points.forEach((p, i) => {\n            p.toArray(this.position, i * 3 * 2);\n            p.toArray(this.position, i * 3 * 2 + 3);\n\n            if (!i) {\n                // If first point, calculate prev using the distance to 2nd point\n                tmp.copy(p)\n                    .sub(this.points[i + 1])\n                    .add(p);\n                tmp.toArray(this.prev, i * 3 * 2);\n                tmp.toArray(this.prev, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.next, (i - 1) * 3 * 2);\n                p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n            }\n\n            if (i === this.points.length - 1) {\n                // If last point, calculate next using distance to 2nd last point\n                tmp.copy(p)\n                    .sub(this.points[i - 1])\n                    .add(p);\n                tmp.toArray(this.next, i * 3 * 2);\n                tmp.toArray(this.next, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.prev, (i + 1) * 3 * 2);\n                p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n            }\n        });\n\n        this.geometry.attributes.position.needsUpdate = true;\n        this.geometry.attributes.prev.needsUpdate = true;\n        this.geometry.attributes.next.needsUpdate = true;\n    }\n\n    // Only need to call if not handling resolution uniforms manually\n    resize() {\n        // Update automatic uniforms if not overridden\n        if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n        if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}