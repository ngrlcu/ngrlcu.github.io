{"ast":null,"code":"import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\nexport class Cylinder extends Geometry {\n  constructor(gl) {\n    let {\n      radiusTop = 0.5,\n      radiusBottom = 0.5,\n      height = 1,\n      radialSegments = 8,\n      heightSegments = 1,\n      openEnded = false,\n      thetaStart = 0,\n      thetaLength = Math.PI * 2,\n      attributes = {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rSegs = radialSegments;\n    const hSegs = heightSegments;\n    const tStart = thetaStart;\n    const tLength = thetaLength;\n    const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n    const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n    const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let ii = 0;\n    const indexArray = [];\n    addHeight();\n    if (!openEnded) {\n      if (radiusTop) addCap(true);\n      if (radiusBottom) addCap(false);\n    }\n    function addHeight() {\n      let x, y;\n      const n = new Vec3();\n      const slope = (radiusBottom - radiusTop) / height;\n      for (y = 0; y <= hSegs; y++) {\n        const indexRow = [];\n        const v = y / hSegs;\n        const r = v * (radiusBottom - radiusTop) + radiusTop;\n        for (x = 0; x <= rSegs; x++) {\n          const u = x / rSegs;\n          const theta = u * tLength + tStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n          n.set(sinTheta, slope, cosTheta).normalize();\n          normal.set([n.x, n.y, n.z], i * 3);\n          uv.set([u, 1 - v], i * 2);\n          indexRow.push(i++);\n        }\n        indexArray.push(indexRow);\n      }\n      for (x = 0; x < rSegs; x++) {\n        for (y = 0; y < hSegs; y++) {\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n          index.set([a, b, d, b, c, d], ii * 3);\n          ii += 2;\n        }\n      }\n    }\n    function addCap(isTop) {\n      let x;\n      const r = isTop === true ? radiusTop : radiusBottom;\n      const sign = isTop === true ? 1 : -1;\n      const centerIndex = i;\n      position.set([0, 0.5 * height * sign, 0], i * 3);\n      normal.set([0, sign, 0], i * 3);\n      uv.set([0.5, 0.5], i * 2);\n      i++;\n      for (x = 0; x <= rSegs; x++) {\n        const u = x / rSegs;\n        const theta = u * tLength + tStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n        normal.set([0, sign, 0], i * 3);\n        uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n        i++;\n      }\n      for (x = 0; x < rSegs; x++) {\n        const j = centerIndex + x + 1;\n        if (isTop) {\n          index.set([j, j + 1, centerIndex], ii * 3);\n        } else {\n          index.set([j + 1, j, centerIndex], ii * 3);\n        }\n        ii++;\n      }\n    }\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n}","map":{"version":3,"names":["Geometry","Vec3","Cylinder","constructor","gl","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","Math","PI","attributes","arguments","length","undefined","rSegs","hSegs","tStart","tLength","numCaps","num","numIndices","position","Float32Array","normal","uv","index","Uint32Array","Uint16Array","i","ii","indexArray","addHeight","addCap","x","y","n","slope","indexRow","v","r","u","theta","sinTheta","sin","cosTheta","cos","set","normalize","z","push","a","b","c","d","isTop","sign","centerIndex","j","Object","assign","size","data"],"sources":["/home/nigro/Documents/personal_website/ngrlcu.github.io/node_modules/ogl/src/extras/Cylinder.js"],"sourcesContent":["import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Cylinder extends Geometry {\n    constructor(\n        gl,\n        {\n            radiusTop = 0.5,\n            radiusBottom = 0.5,\n            height = 1,\n            radialSegments = 8,\n            heightSegments = 1,\n            openEnded = false,\n            thetaStart = 0,\n            thetaLength = Math.PI * 2,\n            attributes = {},\n        } = {}\n    ) {\n        const rSegs = radialSegments;\n        const hSegs = heightSegments;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n        const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n        const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n        const indexArray = [];\n\n        addHeight();\n        if (!openEnded) {\n            if (radiusTop) addCap(true);\n            if (radiusBottom) addCap(false);\n        }\n\n        function addHeight() {\n            let x, y;\n            const n = new Vec3();\n            const slope = (radiusBottom - radiusTop) / height;\n\n            for (y = 0; y <= hSegs; y++) {\n                const indexRow = [];\n                const v = y / hSegs;\n\n                const r = v * (radiusBottom - radiusTop) + radiusTop;\n                for (x = 0; x <= rSegs; x++) {\n                    const u = x / rSegs;\n                    const theta = u * tLength + tStart;\n                    const sinTheta = Math.sin(theta);\n                    const cosTheta = Math.cos(theta);\n\n                    position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n                    n.set(sinTheta, slope, cosTheta).normalize();\n                    normal.set([n.x, n.y, n.z], i * 3);\n                    uv.set([u, 1 - v], i * 2);\n                    indexRow.push(i++);\n                }\n                indexArray.push(indexRow);\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                for (y = 0; y < hSegs; y++) {\n                    const a = indexArray[y][x];\n                    const b = indexArray[y + 1][x];\n                    const c = indexArray[y + 1][x + 1];\n                    const d = indexArray[y][x + 1];\n\n                    index.set([a, b, d, b, c, d], ii * 3);\n                    ii += 2;\n                }\n            }\n        }\n\n        function addCap(isTop) {\n            let x;\n            const r = isTop === true ? radiusTop : radiusBottom;\n            const sign = isTop === true ? 1 : -1;\n\n            const centerIndex = i;\n            position.set([0, 0.5 * height * sign, 0], i * 3);\n            normal.set([0, sign, 0], i * 3);\n            uv.set([0.5, 0.5], i * 2);\n            i++;\n\n            for (x = 0; x <= rSegs; x++) {\n                const u = x / rSegs;\n                const theta = u * tLength + tStart;\n                const cosTheta = Math.cos(theta);\n                const sinTheta = Math.sin(theta);\n\n                position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n                normal.set([0, sign, 0], i * 3);\n                uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n                i++;\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                const j = centerIndex + x + 1;\n                if (isTop) {\n                    index.set([j, j + 1, centerIndex], ii * 3);\n                } else {\n                    index.set([j + 1, j, centerIndex], ii * 3);\n                }\n                ii++;\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}